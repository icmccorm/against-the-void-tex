Rust's safety guarantees build on several core principles. Values in Rust have either move or copy semantics. Values with copy semantics do not have an owner and can be copied freely, while values with move semantics have a unique owner. Ownership is transferred through assignment, and a value will be deallocated when its owner goes out of scope \cite{rustbook}.  Ownership can be borrowed temporarily by creating a reference, and each reference is associated with a lifetime: the duration of the program for which it must be valid. A reference's lifetime cannot exceed the lifetime or scope of the value it refers to, and a value can have either one mutable reference or many immutable references in any scope~\cite{crichton20}.

These rules are conservative and are not universally compatible with certain idioms of systems programming. Rust allows developers to circumvent its restrictions using the \unsafe keyword, which enables features that escape the limitations of the borrow checker. Within an \unsafe context, users can dereference raw pointers, execute inline assembly instructions, modify static mutable state, implement \unsafe traits, and call \unsafe functions~\cite{rustbook}. There are multiple dimensions to how these features can be used. In some cases, \unsafe is necessary to implement safe patterns that are incompatible with the borrow checker's restrictions, such as shared ownership. Foreign function calls, inline assembly, and intrinsics allow developers to interact with contexts external to Rust, which are not constrained by the borrow checker. These features can also support methods for improving performance, such as bypassing runtime checks or leveraging hardware acceleration.

The Rust community recommends that API developers avoid exposing \unsafe interfaces to consumers. Instead, developers should follow the ``interior unsafety'' pattern~\cite{qin20} by hiding \unsafe operations beneath a safe interface. The interface should be sound for all possible inputs and program states. Otherwise, developers should expose an \unsafe interface, indicating that consumers are responsible for meeting its safety requirements.
%Rust's standard library provides several types that model these patterns, such as \code{Box<T>} and \code{Rc<T>}. These types encapsulate fundamentally \unsafe allocation functions to provide unique and shared ownership over heap allocations, respectively. Each type has numerous safe API endpoints, but the underlying allocation can be accessed as a raw pointer through their implementations of the \unsafe method \code{into\_raw()}. 


\subsection{Development Tools \& Verification}
Rust supports a diverse set of tools that developers can use to generate and verify code. Automated reasoning is particularly useful in \unsafe contexts, where developers need to build interfaces and establish invariants that Rust's type system cannot verify. 

\subsubsection{Linting \& Static Analysis}
Rust's cargo build tool supports multiple first-party and third-party plugins. By default, this includes rustfmt~\cite{rustfmt}, a code formatting tool, and Clippy~\cite{clippy}, a linting tool. Other extensions can help enforce safety properties. Both cargo-audit~\cite{cargoaudit} and cargo-deny~\cite{cargodeny} detect security vulnerabilities in a project's dependencies. However, cargo-deny is more extensible. The cargo-geiger~\cite{cargogeiger} plugin provides statistics on \unsafe code. Developers can also track if code has been reviewed by a trusted party with cargo-vet~\cite{cargovet}. 

\paragraph{Dynamic Analysis} Rust is compatible with several popular dynamic bug-finding tools, including the LLVM project's sanitizers~\cite{clang}, libFuzzer~\cite{libfuzzer}, and Valgrind~\cite{seward07}. The Rust toolchain also includes Miri, an interpreter that can detect multiple types of undefined behavior that occur due to \unsafe code. Miri models Rust's operational semantics~\cite{stacked_borrows, tree_borrows} to detect when \unsafe features violate the borrow checker's aliasing assumptions. Currently, Miri cannot execute foreign functions or inline assembly, but the Krabcake project~\cite{krabcake} aims to provide this functionality by extending Valgrind with Miri's borrow tracking features. 

\paragraph{Verification} There are multiple approaches to formally verifying Rust code, and each has a different level of compatibility with \unsafe features. Verus~\cite{lattuada23}, a deductive verifier, and Kani~\cite{kani_vanhattum22}, a model checker, both support a limited subset of \unsafe features, but neither can fully validate \unsafe code against Rust's aliasing model. Other approaches do not have any support for \unsafe features. Prusti~\cite{prusti_astrauskas19} and Creusot~\cite{creusot_denis22}, both deductive verifiers, and Flux~\cite{lehmann23}, a refinement type checker, take approaches that rely on Rust's aliasing invariants to simplify formal specifications. RefinedRust~\cite{refinedrust} extends on prior work on ownership verification for C~\cite{sammler21}, and it could provide more comprehensive support for verifying \unsafe features. 

\paragraph{Foreign Bindings \& Encapsulations}
Multiple third-party tools can assist developers with interoperating between Rust and other languages. There are typically two steps to this process; creating an \unsafe function declaration and encapsulating it in a safe interface. The tool bindgen~\cite{bindgen} automatically generates a Rust library containing foreign function declarations, constants, and struct definitions that match the interface of a given C or \CC{} library. Tools such as cbindgen~\cite{cbindgen} operate in reverse, generating foreign interfaces for Rust libraries. Other tools, such as CXX~\cite{cxx}, provide support for both binding and encapsulating foreign calls and can enable bidirectional interoperation.

\subsection{Community Guidelines}
In addition to development tools, multiple community resources provide documentation on how to use \unsafe code correctly. Both The Rust Reference~\cite{rustref} and The Rust Programming Language~\cite{rustbook} have sections related to \unsafe features, while The Rustonomicon~\cite{nomicon} is dedicated entirely to \unsafe code. The Rust Project's Unsafe Code Guidelines Working Group created the Unsafe Code Guidelines Reference~\cite{ucgref} as an in-depth guide to the semantics of \unsafe features, but it is incomplete and mostly unmaintained. However, the ``Issues'' section of its GitHub repository is still used to discuss Rust's semantics. 

%Community contributions that remove \unsafe are not always well-received. Rust's packages are referred to as ``crates'' and the most prominent package repository is \code{crates.io}. A 2020 audit of several crates that provide HTTP clients revealed that the \code{actix-web} crate had a soundness error, and an issue was filed. The author was unaware that this problem had existed, and they believed up to this point that their code upheld Rust's invariants on aliasing and mutability~\cite{actix_web_postmortem}. However, they decided to delete the issue, and they later quit the project after facing community backlash for this decision. A letter of support was signed by 120 members of the Rust community~\cite{actix_web_letter}, and the \code{actix-web} project continues today under new leadership.