Our results indicate that Rust's tooling and community practices do not yet adequately support developers' use cases for \unsafe code. Safe encapsulation is helpful, but it is not a complete solution\textemdash API designers still rely on ad-hoc reasoning over formal assurances, and consumers rarely audit their dependencies. This combination of uncertainty and implicit trust must be addressed to make Rust's promise of static safety a reality. We provide the following recommendations:

\paragraph{For Rust Developers} Developers should reflect on their motivations and rationale before deciding to use \unsafe code. Is there empirical evidence that \unsafe code increases performance? Are the benefits from using \unsafe to improve ergonomics worth the additional overhead of manually reasoning about soundness? If \unsafe code is truly unavoidable, then developers should make use of Rust's tight integration with a variety of powerful development tools. Both Miri and cargo-audit should be considered essential for effective Rust development, even if an application only consumes safe APIs.
\paragraph{For Researchers} Developers cite layered motivations for using \unsafe code, and the soundness of any particular \unsafe construct depends on both its semantics and its use in practice. To accurately describe the role of \unsafe in the Rust ecosystem, researchers should separate developers' cited motivations for using a given feature from that feature's functional characteristics. Any individual use of a feature, such as marking a function as \unsafe, may be motivated by a combination of necessity, performance, or ease-of-use.


\FPeval{\nomiri}{round(100 - \ArrayItem{rq5.tool.miri}, 0)}
\paragraph{For the Rust Team} It is heartening that the majority of respondents used Miri, but it is also also somewhat troubling that more than a third (\nomiri\%) had never done so. The Rust team should consider making Miri easier to access by moving it into Rust's stable toolchain or by having it installed by default with the nightly toolchain. Additional emphasis on the benefits of Miri in introductory resources would also be helpful, as projects that use only safe code may rely on unsound encapsulations of \unsafe features. Miri's lack of support for foreign function calls also represents a critical safety gap for Rust. The Krabcake project is a promising solution, and the Rust team should invest resources into making it production-ready. However, other architectural approaches should also be considered, such LLVM's Sanitizer API.

\paragraph{For Interoperation Tool Developers} Interoperation tools could be improved with automated reasoning for inferring the aliasing and thread-safety properties of foreign functions. This information could be used to generate safe encapsulations for generated bindings. For example, contributors to Clang have proposed a form of lifetime annotation inference for \CC{}~\cite{lifetime_inference}. If sound and feasible, these annotations could be lifted from \CC{} function declarations to generate Rust bindings with equivalent annotations. A similar form of verification for thread-safety properties would also be helpful to determining if foreign types can implement \code{Send} or \code{Sync} or to warn when foreign functions retain copies of reference-type arguments.

\paragraph{For Educators} The Rustonomicon~\cite{nomicon} is a helpful entry point for learning about Rust's \unsafe features, but its one-size-fits-all approach will inevitably leave certain categories of users wanting more targeted information. We agree with Holtervennhoff et al.~\cite{holtervennhoff23} that Rust developers need a dedicated resource that succinctly summarizes ongoing debates about Rust's semantics. Additionally, we find that library developers may also benefit from targeted resources on how to manage \unsafe code in API design.
